<!doctype html>
<meta charset="utf8">
<pre class="metadata">
title: Joint Iteration
status: proposal
stage: 1
contributors: Michael Ficarra
location: https://tc39.es/proposal-joint-iteration/
copyright: false
</pre>

<emu-clause id="sec-iterator.zip">
  <h1>Iterator.zip ( _iterables_ [ , _options_ ] )</h1>
  <p>This method performs the following steps when called:</p>
  <emu-alg>
    1. If _iterables_ is not an Object, throw a *TypeError* exception.
    1. Set _options_ to ? GetOptionsObject(_options_).
    1. Let _longest_ be ? GetOption(_options_, *"longest"*, ~boolean~, ~empty~, *false*).
    1. Let _strict_ be ? GetOption(_options_, *"strict"*, ~boolean~, ~empty~, *false*).
    1. If _longest_ is *true* and _strict_ is *true*, throw a *TypeError* exception.
    1. Let _mode_ be ~shortest~.
    1. Let _fillersOption_ be *undefined*.
    1. If _longest_ is *true*, then
      1. Set _mode_ to ~longest~.
      1. Set _fillersOption_ to ? Get(_options_, *"fillers"*).
    1. If _strict_ is *true*, set _mode_ to ~strict~.
    1. Let _iters_ be a new empty List.
    1. Let _openIters_ be a new empty List.
    1. Let _fillers_ be a new empty List.
    1. If ? HasProperty(_iterables_, %Symbol.iterator%) is *true*, then
      1. Let _inputIter_ be ? GetIterator(_iterables_, ~sync~).
      1. Append _inputIter_ to _openIters_.
      1. Let _next_ be ? IteratorStep(_inputIter_).
      1. Repeat, while _next_ is not *false*,
        1. Let _value_ be Completion(IteratorValue(_next_)).
        1. IfAbruptCloseIterators(_value_, _openIters_).
        1. Let _iter_ be Completion(GetIteratorFlattenable(_value_, ~iterate-strings~)).
        1. IfAbruptCloseIterators(_iter_, _openIters_).
        1. Append _iter_ to _iters_.
        1. Append _iter_ to _openIters_.
        1. Set _next_ to Completion(IteratorStep(_inputIter_)).
        1. IfAbruptCloseIterators(_next_, _openIters_).
      1. Remove _inputIter_ from _openIters_.
      1. If _mode_ is ~longest~, then
        1. If _fillersOption_ is *undefined*, then
          1. For each element _unused_ of _iters_, append *undefined* to _fillers_.
        1. Else,
          1. Let _fillersIter_ be Completion(GetIteratorFlattenable(_fillersOption_, ~iterate-strings~)).
          1. IfAbruptCloseIterators(_fillersIter_, _openIters_).
          1. Let _usingIterator_ be *true*.
          1. For each element _unused_ of _iters_, do
            1. If _usingIterator_ is *true*, then
              1. Set _next_ to Completion(IteratorStep(_fillersIter_)).
              1. IfAbruptCloseIterators(_openIters_).
              1. If _next_ is *false*, then
                1. Set _usingIterator_ to *false*.
              1. Else,
                1. Let _value_ be Completion(IteratorValue(_next_)).
                1. IfAbruptCloseIterators(_value_, _openIters_).
                1. Append _value_ to _fillers_.
            1. If _usingIterator_ is *false*, append *undefined* to _fillers_.
          1. If _usingIterator_ is *true*, then
            1. Let _completion_ be Completion(IteratorClose(_fillersIter_, NormalCompletion(~unused~))).
            1. IfAbruptCloseIterators(_completion_, _openIters_).
      1. Let _finishResults_ be a new Abstract Closure with parameters (_results_) that captures nothing and performs the following steps when called:
        1. Return CreateArrayFromList(_results_).
    1. Else,
      1. Let _allKeys_ be ? _iterables_.[[OwnPropertyKeys]]().
      1. Let _keys_ be a new empty List.
      1. For each element _key_ of _allKeys_, do
        1. Let _desc_ be ? _iterables_.[[GetOwnProperty]](_key_).
        1. If _desc_ is not *undefined* and _desc_.[[Enumerable]] is *true*, append _key_ to _keys_.
      1. For each element _key_ of _keys_, do
        1. Let _value_ be Completion(Get(_iterables_, _key_)).
        1. IfAbruptCloseIterators(_value_, _openIters_).
        1. Let _iter_ be Completion(GetIteratorFlattenable(_value_, ~iterate-strings~)).
        1. IfAbruptCloseIterators(_iter_, _openIters_).
        1. Append _iter_ to _iters_.
        1. Append _iter_ to _openIters_.
      1. If _mode_ is ~longest~, then
        1. If _fillersOption_ is *undefined*, then
          1. For each element _unused_ of _iters_, append *undefined* to _fillers_.
        1. Else,
          1. For each element _key_ of _keys_, do
            1. Let _value_ be Completion(Get(_fillersOption_, _key_)).
            1. IfAbruptCloseIterators(_value_, _openIters_).
            1. Append _value_ to _fillers_.
      1. Let _finishResults_ be a new Abstract Closure with parameters (_results_) that captures _keys_ and performs the following steps when called:
        1. Let _obj_ be OrdinaryObjectCreate(*null*).
        1. Let _count_ be the number of elements in _keys_.
        1. For each integer _i_ such that 0 ≤ _i_ &lt; _count_, do
          1. Perform ! CreateDataPropertyOrThrow(_obj_, _keys_[_i_], _results_[_i_]).
        1. Return _obj_.
    1. Let _closure_ be a new Abstract Closure with no parameters that captures _iters_, _openIters_, _mode_, _fillers_, and _finishResults_, and performs the following steps when called:
      1. Let _iterCount_ be the number of elements in _iters_.
      1. Repeat,
        1. Let _results_ be a new empty List.
        1. Let _observedStrictEnding_ be *false*.
        1. For each integer _i_ such that 0 ≤ _i_ &lt; _iterCount_, in ascending order, do
          1. If _iters_[_i_] is *null*, then
            1. Let _result_ be _fillers_[_i_].
          1. Else,
            1. Let _result_ be Completion(IteratorStep(_iters_[_i_])).
            1. If _result_ is an abrupt completion, then
              1. Remove _iters_[_i_] from _openIters_.
              1. Return ? IteratorCloseAll(_openIters_, _result_).
            1. Set _result_ to _result_.[[Value]].
            1. If _result_ is *false*, then
              1. Remove _iters_[_i_] from _openIters_.
              1. If _mode_ is ~shortest~, then
                1. Return ? IteratorCloseAll(_openIters_, NormalCompletion(*undefined*)).
              1. Else if _mode_ is ~strict~, then
                1. If _observedStrictEnding_ is *false* and _i_ ≠ 0, then
                  1. Return ? IteratorCloseAll(_openIters_, ThrowCompletion(a newly created *TypeError* object)).
                1. Set _observedStrictEnding_ to *true*.
              1. Else,
                1. Set _iters_[_i_] to *null*.
                1. Set _result_ to _fillers_[_i_].
            1. Else,
              1. If _observedStrictEnding_ is *true*, then
                1. Return ? IteratorCloseAll(_openIters_, ThrowCompletion(a newly created *TypeError* object)).
              1. Set _result_ to Completion(IteratorValue(_result_)).
              1. If _result_ is an abrupt completion, then
                1. Remove _iters_[_i_] from _openIters_.
                1. Return ? IteratorCloseAll(_openIters_, _result_).
              1. Set _result_ to _result_.[[Value]].
          1. Set _results_[_i_] to _result_.
        1. Set _results_ to _finishResults_(_results_).
        1. Let _completion_ be Completion(Yield(_results_)).
        1. If _completion_ is an abrupt completion, then
          1. Return ? IteratorCloseAll(_openIters_, _completion_).
    1. Let _gen_ be CreateIteratorFromClosure(_closure_, *"Iterator Helper"*, %IteratorHelperPrototype%, « [[UnderlyingIterators]] »).
    1. Set _gen_.[[UnderlyingIterators]] to _openIters_.
    1. Return _gen_.
  </emu-alg>
</emu-clause>

<emu-clause id="sec-closeall" type="abstract operation">
  <h1>
    IteratorCloseAll (
      _iters_: a List of Iterator Records,
      _completion_: a Completion Record,
    ): a Completion Record
  </h1>
  <dl class="header">
    <dt>description</dt>
    <dd>TODO</dd>
  </dl>
  <emu-alg>
    1. TODO: should this be in reverse order?.
    1. For each element _iter_ of _iters_, do
      1. Set _completion_ to Completion(IteratorClose(_iter_, _completion_)).
    1. Return ? _completion_.
  </emu-alg>
</emu-clause>

<emu-clause id="sec-ifabruptcloseiterators" aoid="IfAbruptCloseIterators">
  <h1>IfAbruptCloseIterators ( _value_, _iteratorRecords_ )</h1>
  <p>IfAbruptCloseIterators is a shorthand for a sequence of algorithm steps that use a list of Iterator Records. An algorithm step of the form:</p>
  <emu-alg>
    1. IfAbruptCloseIterators(_value_, _iteratorRecords_).
  </emu-alg>
  <p>means the same thing as:</p>
  <emu-alg>
    1. Assert: _value_ is a Completion Record.
    1. If _value_ is an abrupt completion, return ? IteratorCloseAll(_iteratorRecords_, _value_).
    1. Else, set _value_ to _value_.[[Value]].
  </emu-alg>
</emu-clause>

<emu-clause id="sec-%iteratorhelperprototype%.return">
  <h1>%IteratorHelperPrototype%.return ( )</h1>
  <emu-alg>
    1. Let _O_ be *this* value.
    1. <del>Perform ? RequireInternalSlot(_O_, [[UnderlyingIterator]]).</del>
    1. <ins>Perform ? RequireInternalSlot(_O_, [[UnderlyingIterators]]).</ins>
    1. Assert: _O_ has a [[GeneratorState]] slot.
    1. If _O_.[[GeneratorState]] is ~suspended-start~, then
      1. Set _O_.[[GeneratorState]] to ~completed~.
      1. NOTE: Once a generator enters the completed state it never leaves it and its associated execution context is never resumed. Any execution state associated with _O_ can be discarded at this point.
      1. <del>Perform ? IteratorClose(_O_.[[UnderlyingIterator]], NormalCompletion(~unused~)).</del>
      1. <ins>Perform ? IteratorCloseAll(_O_.[[UnderlyingIterators]], NormalCompletion(~unused~)).</ins>
      1. Return CreateIterResultObject(*undefined*, *true*).
    1. Let _C_ be Completion { [[Type]]: ~return~, [[Value]]: *undefined*, [[Target]]: ~empty~ }.
    1. Return ? GeneratorResumeAbrupt(_O_, _C_, *"Iterator Helper"*).
  </emu-alg>
</emu-clause>

<emu-clause id="stolen-infra">
  <h1>Infra</h1>

  <emu-note>
    <p>
      These AOs are taken from ecma402 and are listed here because they will need to move to ecma262. This is the first API in ecma262 that will take an options bag.
    </p>
  </emu-note>

  <emu-clause id="sec-getoptionsobject" type="abstract operation">
    <h1>
      GetOptionsObject (
        _options_: an ECMAScript language value,
      ): either a normal completion containing an Object or a throw completion
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>
        It returns an Object suitable for use with GetOption, either _options_ itself or a default empty Object.
        It throws a *TypeError* if _options_ is not *undefined* and not an Object.
      </dd>
    </dl>
    <emu-alg>
      1. If _options_ is *undefined*, then
        1. Return OrdinaryObjectCreate(*null*).
      1. If Type(_options_) is Object, then
        1. Return _options_.
      1. Throw a *TypeError* exception.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-getoption" type="abstract operation">
    <h1>
      GetOption (
        _options_: an Object,
        _property_: a property key,
        _type_: ~boolean~ or ~string~,
        _values_: ~empty~ or a List of ECMAScript language values,
        _default_: ~required~ or an ECMAScript language value,
      ): either a normal completion containing an ECMAScript language value or a throw completion
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>It extracts the value of the specified property of _options_, converts it to the required _type_, checks whether it is allowed by _values_ if _values_ is not ~empty~, and substitutes _default_ if the value is *undefined*.</dd>
    </dl>
    <emu-alg>
      1. Let _value_ be ? Get(_options_, _property_).
      1. If _value_ is *undefined*, then
        1. If _default_ is ~required~, throw a *RangeError* exception.
        1. Return _default_.
      1. If _type_ is ~boolean~, then
        1. Set _value_ to ToBoolean(_value_).
      1. Else,
        1. Assert: _type_ is ~string~.
        1. Set _value_ to ? ToString(_value_).
      1. If _values_ is not ~empty~ and _values_ does not contain _value_, throw a *RangeError* exception.
      1. Return _value_.
    </emu-alg>
  </emu-clause>
</emu-clause>

